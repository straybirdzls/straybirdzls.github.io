<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Straybird's Blog]]></title>
  <link href="http://straybirdzls.github.io/atom.xml" rel="self"/>
  <link href="http://straybirdzls.github.io/"/>
  <updated>2014-11-21T20:47:14+08:00</updated>
  <id>http://straybirdzls.github.io/</id>
  <author>
    <name><![CDATA[Straybird]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ios学习笔记1]]></title>
    <link href="http://straybirdzls.github.io/blog/2014/11/21/views/"/>
    <updated>2014-11-21T20:40:43+08:00</updated>
    <id>http://straybirdzls.github.io/blog/2014/11/21/views</id>
    <content type="html"><![CDATA[<p>接触iOS这个平台也有1年多的时间了，中途有看过一些书，也看过一些博客，但终究觉得是纸上得来终觉浅。最近也好好思考了一下，对于iOS的学习一直都是随性的，想到啥了就学啥，导致的结果就是有些部分因为比较感兴趣，学的比较深入，有些部分却是一个完完全全的初学者，所以当自己想去写点什么的时候，总是有点力不从心。总结了一下，现在对于objetctive－c的语法，以及ios的内存管理，多线程等方面至少是应该跨过了初学者的层次，但是对于view，controller还有Apple提供的api等知道的甚少。正好最近有同事推荐了<iOS Programming: The Big Nerd Ranch Guides>，网上看了一下，觉得挺不错的，对于现阶段的我，正好可以查缺补漏，同时练手和巩固已有知识。这个学习笔记系列也就是我学习过程中的一些记录。</p>

<h3>id和instancetype</h3>

<p><code>instanceytype</code>只能够作为返回值类型，并且会返回当前的class类型，相对于id而言，其可以让编译器帮我们做更多的事情。之前我也想过，为什么初始化中一定要返回<code>id</code>或者<code>instancetype</code>，不能直接返回类类型呢？在书中也找到了答案，其实很简单，如果类被子类化了怎么办?子类覆盖?我们知道objeitive－c中是不能有selector名字一致但是返回类型不一致的方法的。</p>

<h3>view/controller相关</h3>

<h5>Point和Pixel</h5>

<p>涉及到viewer层面，就不得不提Point和Pixel了，Point的大小参数是保持一致的，根据屏幕分辨率的不同，其对应的Pixel的数量会发生改变。在非Retina屏中，1个Point就是Pixel，但在Retina中，以额Point变为了2*2Pixel。所以对于图片而言，苹果提高了非常便捷的方式，就是用2份图片，在Retina中使用的在名字后加上@2x就可以了。</p>

<h5>lazy loading</h5>

<p>对于view而言，没有显示在屏幕之上前，viewcontroller是没有必要去loading的，同时也考虑到移动端的内存，我们应该尽量做到这样。所以我们一定要注意，没有必要的时候不要在这之前调用self.view，尤其不要在init中调用，这样会造成view的提前加载。</p>

<h5>xib命名</h5>

<p>xib的命名最好与viewcontroller的名字保持一致，这是为什么呢？因为<code>initWithNibName</code>调用时，如果发现nib参数为空，会检测与viewcontroller同名的nib文件，也就是说名字保持一致后，就可以直接使用init初始化了，这样是不是方便很多？</p>

<h5>File&rsquo;s owner</h5>

<p>对于xib而言，设置file&rsquo;s owner非常重要，这是为什么呢，如果不设置，当viewcontroller加载nib时，元素都准备好了，却会发现自己的view指向nil，将xib的file&rsquo;s owner设置为对应的view controller，就可以将view的outlet设置为file&rsquo;s owner了，这样，加载的时候，view controller成为file&rsquo;s owner，就能找到对应的view了。</p>

<h5>outlet的背后</h5>

<p>在xib上设置outlet只需要简单的拖动，那实际上view上的元素outlet到底是怎么跟viewcontroller中的property连接起来的呢？这背后其作用的就是<code>kvc(key-value coding)</code>了,首先会寻找setter/getter，然后是成员变量(var和_var)，所以当设置好outlet之后，如果将对应的property改名，就会寻找不到，也是这个原因。</p>

<h5>Core Graphics</h5>

<p>Core Graphics是用纯c语言实现的2D作图引擎，其中有一些以Ref结尾的类型需要注意，他们其实是指针对象的，用Ref又作了一层封装以与其他的Core框架对象保持一致(Core Foundation中也有很多这样的)，尽管这些对象是存在堆上的，但是ARC不帮忙管理内存，需要我们自己管理。大部分时候我们我们都会选用跟高层面的实现UIBezierPath,但是阴影和渐变只能用Core Foundation实现。</p>

<p>这一篇记录的也比较杂，主要是根据学习的顺序吧，记录的目的也就是帮助自己巩固知新。</p>

<h3>参考文献</h3>

<p>书籍: iOS Programming: The Big Nerd Ranch Guides</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python学习笔记]]></title>
    <link href="http://straybirdzls.github.io/blog/2014/11/18/pythonstart/"/>
    <updated>2014-11-18T22:50:01+08:00</updated>
    <id>http://straybirdzls.github.io/blog/2014/11/18/pythonstart</id>
    <content type="html"><![CDATA[<p>最近开始学习coursera上的<a href="https://class.coursera.org/pythonlearn-003">python教程</a>,这门课程相当简单，是面向刚接触编程的，对于已经有个编程基础的，可以权当花少量的时间，过一下语法。我学这门课程花的时间也不多，发现python语法中的确有一些不一样的地方，这里记录一下。</p>

<h4>缩排</h4>

<p>python中识别代码快是用缩进的，值得注意的是要保持缩进的格式一致，一定记得不要将tab和空格混用，否则容易带来很难检查的缩进错误，建议编写python代码时，将编辑器做一些设定，让tab自动成为空格。</p>

<!--more-->


<h4>值得注意的语法</h4>

<p>python中还是有不少语法跟之前接触过的有不少的差别，这里列一些我觉得值得注意的</p>

<ol>
<li>语句末尾不需要;作为结束符，有的话会报错</li>
<li>很多常见的语句都需要用:结尾 比如<code>if/elif/else／if not,try/except,def,while,for...in</code>,且这些语句的内容都不需要用()包起来，我一开始总是习惯性地打括号。</li>
<li><code>for...in:</code>非常好用，不仅仅对于数组，对于字符串也可以直接使用，遍历起来非常方便。对于文件也非常好用，利用<code>open()</code>打开文件之后，就可以直接用其来遍历文件的内容，如果用<code>read</code>,则是将文件内容读入到字符串中。</li>
<li>字符串自带的处理函数很丰富，使用<code>dir(str)</code>即可查看内建的字符串函数，很常用的有<code>lstrip()/strip()/rstrip()</code>,<code>split()</code>,<code>startswith()/endswith()</code>等等。</li>
<li>很好用的<code>in</code>,这里的<code>in</code>不是<code>for...in</code>里面的那个，其可以直接用来判断字符串中是否包含子串，数组中是否包含某元素等,当然对应的还有<code>not in</code>。</li>
<li><code>list</code>很好用，遍历等的方式也都跟字符串保持一致，但字符串本身赋值后就不能修改，修改会报错，其是&#8221;不可变的&#8221;，而<code>list</code>则可以，其是&#8221;可变的&#8221;。</li>
<li>字符串使用<code>split()</code>可以生成<code>list</code>，<code>split()</code>也可以带参数，指定分割字符串所用的符号,非常好用。</li>
<li>多行知注释是以    <code>'''</code>来包含的。</li>
</ol>


<h4>is和==</h4>

<p>python中判断是否相等，有<code>is</code>和<code>==</code>，其中<code>is</code>是判断是否相等，而==则用同时判断值和类型，比如1=＝1.0返回True，而1 is 1.1返回False。提到<code>is</code>，就不得不提<code>None</code>,<code>None</code>表示参数未定义，一般情况下判断是否为<code>None</code>，都推荐用<code>is</code>。</p>

<p>由于这个公开课还没有完结，而课程是一周一周出的，我这里暂时也只记录了前面8周的一些笔记，后面的课程跟了，也会来更新记录。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[谈谈Foundation]]></title>
    <link href="http://straybirdzls.github.io/blog/2014/11/16/xianche/"/>
    <updated>2014-11-16T20:20:49+08:00</updated>
    <id>http://straybirdzls.github.io/blog/2014/11/16/xianche</id>
    <content type="html"><![CDATA[<p>Founcation Kit是Cocoa中非常重要的一员，其提供了很多方便使用的数据对象类型。Foundation是基于Core Foundation实现的，后者是用纯C语言写的，它们之间进行转变也非常方便。这一篇我主要是记录一些在学习Foundation中觉得应该特别注意的几个点。</p>

<h4>类簇</h4>

<p>在Foundation中类簇非常常见，比如<code>NSArray,NSNumber</code>等。类簇的本质其实是抽象工厂模式，使用这个的好处就是用户在使用这些<code>NSArray,NSNumber</code>时，不用去考虑具体实例化的对象是属于什么类。值得注意一点的是，千万不要创建类簇的子类，处理不好的话会是灾难。关于类簇，更多的信息可见参考文献2，该文阐述的非常清晰，并给出了具体的使用场景。</p>

<!--more-->


<h4>Copy</h4>

<p>关于拷贝，objective-c中提供了<code>copy</code>关键字，容易混淆的还有<code>retain</code>关键字。一般认为<code>retain</code>为指针拷贝，<code>copy</code>为内容拷贝，内容拷贝中又包含了深拷贝和浅拷贝。对于不可变的对象而言，copy做的事情与retain保持了一致:引用计数加1;对于可变的对象而言，copy是浅拷贝。测试代码如下:</p>

<pre><code>NSMutableArray *mutableArray = [NSMutableArray arrayWithObject:@"test"];
NSMutableDictionary *mutableDictionary = [NSMutableDictionary dictionaryWithObject:@"test1" forKey:@"1"];
[mutableArray addObject:mutableDictionary];
NSArray *array = [mutableArray copy];
[mutableDictionary setObject:@"test2" forKey:@"2"];
[mutableArray addObject:@"test3"];
NSLog(@"array is %@",array);
NSLog(@"mutableArray is %@",mutableArray);
</code></pre>

<p>输出结果如下，可以看到array中mutableDictionary依然会跟着改变。</p>

<pre><code>array is (test,{1 = test1;2 = test2;})
mutableArray is (test,{1 = test1;2 = test2;},test3)
</code></pre>

<h4>什么时候不应该使用属性?</h4>

<p>这一点属于摘录，在参考文献1中提到</p>

<blockquote><p>在初始化方法或者是 dealloc 中最好不要使用属性，因为你无法确定 self 到底是不是确实调用的是你想要的实例</p></blockquote>

<p>在<a href="%E6%AD%A4%E6%96%87">此文</a>中,我也看到类似的论述，虽然也许在<code>init</code>或者<code>dealloc</code>使用属性大部分时候不会带来问题，但还是应该小心为妙。</p>

<p>在参考文献1中，关于Foundation，都是一些非常好的文章，我这里只记录了我暂时看到的几点，只是一点点皮毛，推荐有兴趣的人看看那些文章。</p>

<h3>参考文献</h3>

<p><a href="http://objccn.io/issue-7/">objc中国:#7 Foundation</a><br/>
<a href="http://limboy.me/ios/2014/01/04/class-cluster.html">类簇来iOS开发中的应用</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[读书笔记(3) iOS与OSX多线程和内存管理]]></title>
    <link href="http://straybirdzls.github.io/blog/2014/11/11/memeorybook3/"/>
    <updated>2014-11-11T20:30:54+08:00</updated>
    <id>http://straybirdzls.github.io/blog/2014/11/11/memeorybook3</id>
    <content type="html"><![CDATA[<p>今天是&lt;iOS与OSX多线程和内存管理>读书笔记的最后一篇了，主题是多线程。书中主要是讲GCD,并没有讲NSOperation的东西，我这一篇一方面简要地对GCD记录一些知识点，也谈一点点NSOperation方面的东西。对于NSOperation方面的知识，我看了很多人推荐的<a href="http://www.raywenderlich.com/19788/how-to-use-nsoperations-and-nsoperationqueues">教程</a>，觉得写得非常好，推荐想学习的人看一看。</p>

<h4>慎用@sync</h4>

<p>从字面意思<code>@async</code>是异步执行，那<code>@sync</code>就是同步执行了。使用<code>@sync</code>时一定要万分小心，比如主线程，则会直接造成阻塞，死锁。因为任务执行完之后才会返回，但任务又必须等待其之前的任务完成才能执行。</p>

<!--more-->


<h4>UI刷新</h4>

<p>移动端非常注重用户体验，所以UI刷新一定要放在主线程。若使用GCD，可以用<code>dispatch_get_main_queue()</code>来获取主线程，若使用NSOperation,可以用<code>[NSOperationQueue mainQueue]</code>来获取，当然也可以通过delegate使用<code>performSelectorOnMainThread</code>来实现。</p>

<h4>一些好用的关键字</h4>

<p>在GCD中，有很多很好用的功能，比如<code>dispatch_once</code>可以保证代码只被调用一次;<code>dispatch_group_async</code>可以定义一组任务，当一组任务全部完成时，会通过<code>dispatch_group_notify</code>来给通知;<code>dispatch_barrier_async</code>用于等待其他任务的完成，并完成任务之后，才能启动之后的任务，对于数据库访问以及文件的读写都非常有用;<code>dispatch_apply</code>是跟<code>@sync</code>和<code>group</code>都有关系的，它可以定义一组任务，并等待其完成;<code>dispatch_semaphore</code>提供类似于<code>dispatch_barrier_async</code>的功能，但是可以保证更小的粒度，它是通过信号量的方式来工作的。</p>

<h4>NSOperationQueue和GCD</h4>

<p>自GCD出来后，NSOperationQueue就是用GCD来实现了。通过对上面推荐的教程的学习，NSOperation对于代码管理是非常方便的，而且可以cancel，对于依赖的管理也非常方便。根据苹果使用high level实现的惯例，一般情况下都是推荐使用NSOperation。当然GCD很轻量级，使用起来非常方便，所以根据具体的使用场景，也有很多需要的时候。</p>

<p>其实书中还讲了很多其他方面的内容，GCD确实很强大，有了它，我们不用自己管理线程，因为这方面我还处于学习阶段，所以暂时还没能有一些比较深刻的见解，有兴趣的可以看objc的这个<a href="http://objcio.cn/issue-2/">专题</a>，讲得非常精彩。截止到现在，这本书&lt;iOS与OSX多线程和内存管理>我也算是粗略地过了一遍，但实践出真知，我现在还处于学习阶段，接下来要多多练习，方能将这些全部变成自己的知识。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[读书笔记(2) iOS与OSX多线程和内存管理]]></title>
    <link href="http://straybirdzls.github.io/blog/2014/11/08/memeorybook2/"/>
    <updated>2014-11-08T20:00:04+08:00</updated>
    <id>http://straybirdzls.github.io/blog/2014/11/08/memeorybook2</id>
    <content type="html"><![CDATA[<p>续上文，这一篇主要记录block中的一些点。block中最需要理解的就2个概念：匿名函数,局部变量，表面看起来很简单，但实际上深究起来，里面的涵义大有可以挖掘的地方。</p>

<h4>访问局部变量</h4>

<p>在block中可以使用局部变量，如下所示：</p>

<pre><code>int i = 1;
^{
    NSLog(@"i is %d",i);
}();
</code></pre>

<p>第一反应也许你会觉得这有什么了不起的？block定义在i之后，可以访问不是很正常么？想想函数，再想想block这种匿名函数，就会明白这的确是有些不一样的。</p>

<!-- more -->


<p>这是怎么实现的呢？block的底层实际上时结构体，这个结构体包含了一些信息，有其函数实现，也有isa指针等。当在block中访问局部变量时，结构体会增加相应的成员变量，并在初始化的时候记录这些局部变量的值。那么为什么不能修改呢？看具体的实现就知道了，只提供了访问的方式，没提供修改的方式。</p>

<p>需要注意一点的是，block中不能访问c数组，原因也很明显了，c中不支持不能直接复制数组名。如想实现类似的功能，改成指针访问就可以了。</p>

<h4>修改局部变量</h4>

<p>修改局部变量的实现针对局部变量的类型分2种：</p>

<p>第一种是局部静态变量，这种的实现很简单，直接用指针获取代替变量获取，就可以实现修改了。</p>

<p>第二种是局部变量，也许你也会问这个不能跟局部静态变量一样吗？原因是block在局部变量的生命域结束之后还要能够存在。所以针对局部变量，情况更复杂一些。用 <code>__block</code>修饰的局部变量会被解析为struct类型，该struct类型中有一个指向自身的指针(<code>__forwarding</code>)，当变量从栈中复制到堆中时，该指针也将指向堆中的变量。为了实现block在局部变量生命域结束之后还能存在，则必须在必要的时候对block从栈中复制到堆中。</p>

<h4>局部对象</h4>

<p>使用局部对象的情况跟变量略微有些不同，因为对象还会考虑所有权修饰符。block不能访问使用<code>__autoreleasing</code>的局部对象，访问<code>__strong</code>或者<code>__weak</code>时，其成员函数中也获取相应类型的变量。</p>

<p>还有一点需要注意，没有使用<code>__block</code>修饰符时，虽然不能让对象重定位，但可以修改，比如增加object之类的，这是什么原因，很简单了，block在获取的时候，是直接赋值的，对象是指针访问，不能修改指针的指向，但修改其指向的内容时没问题的，普通的指向变量的指针也是一样。</p>

<h4>循环引用</h4>

<p>使用block时一定要注意循环引用的问题，一般情况下2种方式解决，一种是使用<code>__weak</code>关键字，一种是使用<code>__block</code>(MRC中使用则不会retain，ARC中会，所以最需要设置为nil)。两种方式各有优劣，使用<code>__weak</code>要考虑<code>__unsafe_unretain</code>,使用<code>__block</code>，则如果block没有执行，循环引用一直存在。</p>

<h4>block类型</h4>

<p>block有3种，简单地说就是: global，stack和heap。</p>

<p>MRC时代，当block中当问局部变量时，默认是在stack上，所以需要的时候需要将其复制到heap上。相较而言，ARC时代对block进行内存管理就容易多了，因为默认就在heap上，也没有stack上这种类型了。</p>

<p>block在objective-c中的确是属于比较难一些的，但是究其根底，其实也还好，书中还有很多内容很精彩，尽管有些部分在ARC时代已经不适用了，但仍然很值得细细品味，我这里只记录了一些很简单的笔记。想自己看实现的也可以通过书中给出的简单的<code>clang -rewrite-objc</code>即可将objc代码转换成c/c++代码。最后附上一个block快速测试的一个<a href="http://blog.parse.com/2013/02/05/objective-c-blocks-quiz/">链接</a>，我也是看到别人的博客推荐，觉得很值得尝试下的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[读书笔记(1) iOS与OSX多线程和内存管理]]></title>
    <link href="http://straybirdzls.github.io/blog/2014/11/04/memorybook/"/>
    <updated>2014-11-04T21:25:41+08:00</updated>
    <id>http://straybirdzls.github.io/blog/2014/11/04/memorybook</id>
    <content type="html"><![CDATA[<p>最近这些天看了&lt;iOS与OSX多线程和内存管理>这边书，觉得这本书还是写得很不错的，这一篇对内存管理中的一些点记一些笔记，主要集中在ARC上，关于block的以后再谈。我这里也不准备从最基本的概念入手，因为介绍ARC的文章已经太多了，所以我只记录一些我觉得比较特殊的点。</p>

<h4>查看自动释放池的状态</h4>

<p>只需要先使用声明:</p>

<pre><code>extern void _objc_autoreleasePoolPrint();
</code></pre>

<p>就可以使用</p>

<pre><code>_objc_autoreleasePoolPrint();
</code></pre>

<p>打印释放池里的状态了。这个API是私有API,对于osx和iOS通用，还有一个API只对iOS可以使用，这里就不提了，个人觉得上面这个API就够用了。</p>

<!--more-->


<p></p>

<h4>ARC下查看retain count</h4>

<p>在启用了ARC的项目中，因为<code>RetainCount</code>已经不能使用了，但有时候我们也想观察一下当前对象到底有多少引用指向，这时候我们就可以使用<code>_objc_rootRetainCount(obj)</code>来查看对象的引用计数。</p>

<h4>使用__weak对象时是否会retain一个对象并放入自动释放池?</h4>

<p>在书中，提到当使用<code>__weak</code>对象时，会<code>retain</code>一个<code>autorealeasing</code>对象，这么做的原因是可以保证在<code>@autoreleasepool</code>块结束之前对象可以保证正常访问。读到这里的时候，我非常困惑，因为实在很难想像有什么这样的使用场景。当没有对象强引用时，<code>__weak</code>对象将会自动指向nil，为什么还要将其放入自动释放池呢? 我百思不得其解。然后在实验书中代码时，我得到了不一样的结果。经过自己实验，我发现应该是苹果改了实现，也许是他们也发现将<code>__weak</code>对象<code>retain</code>一个<code>autorealeasing</code>对象是没有意义的。测试代码如下。</p>

<pre><code>id  __strong obj = [[NSObject alloc]init];
_objc_autoreleasePoolPrint();
id __weak o = obj;
NSLog(@"count: %d",_objc_rootRetainCount(obj));
NSLog(@"class=%@",[o class]);
NSLog(@"count: %d",_objc_rootRetainCount(obj));
_objc_autoreleasePoolPrint();
</code></pre>

<p>在xcode4.6中运行的结果如下，使用__weak，会有相应的对象放入自动释放池。</p>

<pre><code>objc[20987]: ##############
objc[20987]: AUTORELEASE POOLS for thread 0x7fff761d3310
objc[20987]: 1 releases pending.
objc[20987]: [0x100803000]  ................  PAGE  (hot) (cold)
objc[20987]: [0x100803038]  ################  POOL 0x100803038
objc[20987]: ##############
2014-11-04 15:26:15.094 memory-xcode46[20987:303] count: 1
2014-11-04 15:26:15.094 memory-xcode46[20987:303] class=NSObject
2014-11-04 15:26:15.095 memory-xcode46[20987:303] count: 2
objc[20987]: ##############
objc[20987]: AUTORELEASE POOLS for thread 0x7fff761d3310
objc[20987]: 2 releases pending.
objc[20987]: [0x100803000]  ................  PAGE  (hot) (cold)
objc[20987]: [0x100803038]  ################  POOL 0x100803038
objc[20987]: [0x100803040]       0x100500f10  NSObject
objc[20987]: ##############
</code></pre>

<p>在xcode5/xcode6中的运行结果如下，使用__weak，并不会有相应的对象放入自动释放池。</p>

<pre><code>objc[20761]: ##############
objc[20761]: AUTORELEASE POOLS for thread 0x7fff761d3310
objc[20761]: 1 releases pending.
objc[20761]: [0x100803000]  ................  PAGE  (hot) (cold)
objc[20761]: [0x100803038]  ################  POOL 0x100803038
objc[20761]: ##############
2014-11-04 15:20:51.001 memeroy_test_xcode5[20761:303] count: 1
2014-11-04 15:20:51.003 memeroy_test_xcode5[20761:303] class=NSObject
2014-11-04 15:20:51.003 memeroy_test_xcode5[20761:303] count: 1
objc[20761]: ##############
objc[20761]: AUTORELEASE POOLS for thread 0x7fff761d3310
objc[20761]: 1 releases pending.
objc[20761]: [0x100803000]  ................  PAGE  (hot) (cold)
objc[20761]: [0x100803038]  ################  POOL 0x100803038
objc[20761]: ##############
</code></pre>

<p>由此可见，实现确实是不一样了，我尝试找apple的源码，在老版本的<a href="http://www.opensource.apple.com/source/objc4/objc4-493.11/runtime/objc-arr.mm">实现</a>中(objc-arr.mm文件),可以看到: 使用<code>__weak</code>对象确实有相应的对象放入了自动释放池。</p>

<pre><code>id objc_loadWeak(id *location)
{
    return objc_autorelease(objc_loadWeakRetained(location));
}

objc_loadWeakRetained(id *location)
{
    ......
}
</code></pre>

<p>遗憾的时候，在最新<a href="http://www.opensource.apple.com/source/objc4/objc4-646/runtime">源码</a>中，已找不到objc-arc.mm文件，我尝试在其他可能的文件中找objc_loadWeak，可惜没找到，不知道是换到别处去了，还是苹果决定不再公开此文件。于是我尝试了一下在新的版本上查看汇编代码，可以看到直接调用了<code>_objc_loadWeakRetained</code>,这也侧面证明了现在使用<code>__weak</code>对象并没有相应的对象放入释放池。</p>

<pre><code>main.m:50:0
movl    %ecx, -108(%rbp)            callq   _objc_storeStrong
leaq    -32(%rbp), %rdi
.loc    1 52 0                 
callq   _objc_loadWeakRetained
movq    %rax, %rsi
</code></pre>

<p>这本书出来的时间也比较久了，所以可能有些内容跟最新的实现有出入，但通过书中的引子来思考并且找到最终答案让我受益颇多。</p>

<h4>默认一定是__strong?</h4>

<p>ARC声明对象时，默认是<code>__strong</code>的，也即 <code>id test;</code>等同于<code>id __strong test;</code>。但是一定要注意<code>id *test;</code>是等同于<code>id __autoreleasing *test;</code>。即指向对象的指针默认是<code>__autoreleasing</code>的。 分配指向对象的时针时，必须得保证两边得所有权限制符是一致的，像如下的代码，编译器会报错。</p>

<pre><code>NSError *error = nil; 
NSError **pError = &amp;error;
</code></pre>

<p>改成如下就没问题啦。</p>

<pre><code>NSError *error = nil;   NSError * __strong *pError = &amp;error;
</code></pre>

<p>最后总结一下，这本书关于所有权的阐述蛮有意思的，然后对苹果的实现机制也挖掘的比较深入，推荐想了解内存机制的人读一下。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Markdown语法个人总结]]></title>
    <link href="http://straybirdzls.github.io/blog/2014/11/01/marddown/"/>
    <updated>2014-11-01T22:00:01+08:00</updated>
    <id>http://straybirdzls.github.io/blog/2014/11/01/marddown</id>
    <content type="html"><![CDATA[<p>最近开始写博客了，用的是Markdown写然后生成静态网页，最开始的时候只匆匆过了一遍Markdown语法，然后写的时候也懒得去看，觉得很多时候还不如直接使用html方便，但这样导致的问题就是文章的存根不太漂亮，然后我对html的很多标签并不太熟悉，所以写的时候Markdown和html标签混合使用，会遇到一些问题，然后查询所花费的时间也不少。考虑既然想把写博客这件事情继续下去，那还是应该先花些时间在基础建设上。今天将Markdown语法好好地看了一下，下面总结一下，主要记录一下我在写博文中最常用到的一些。</p>

<!--more-->


<h4>标题</h4>

<p>使用＃就可以使用标题了，其中1个到6个分别对应h1到h6。</p>

<h4>换行</h4>

<p>Markdown中如果一段文字前面有空行，则认为是一个新的段落，会自动加上<code>&lt;p&gt;</code> 标签。但如果有时候不想加空行，有更简便的方法可以换行，那就是在一行的末尾加上2个或以上的空格然后回车。</p>

<h4>代码</h4>

<p>技术人员在博客中加入代码是很常用的。有2种形式:</p>

<p>第一种是一段代码，直接在每行开头上加入tab或者4个空格就可以了。之后转换的时候会自动加上<code>&lt;pre&gt;&lt;code&gt;</code>标签。</p>

<p>第二种是在行内加代码，只需要用｀｀包住代码就可以了 ，我上面的行内的的代码就是用这种方式写的。转换的时候会自动加上<code>&lt;code&gt;</code>标签。</p>

<h4>引用</h4>

<p>我们在博文中有时候会引用别人的话语，只需要在段落前加上>就可以了,转换的时候会自动加上<code>&lt;blockquote&gt;</code>。值得注意的是，自带的引用字体太大，显得很不和谐，而且斜体也不是很好看，需要进行一些调整，在sass/base/_typography.scss中改动就可以了。</p>

<h4>列表</h4>

<p>无序列表用<code>+,-,*</code>都可以，注意符号之后必须增加一个空格之后才可以加列表的元素。转换的时候会自动加上<code>&lt;ol&gt;&lt;ul&gt;</code>。</p>

<p>有序列表用数字接着一个英文句话就可以，值得注意的是前面的数字并不会影响最后生成的静态网站。转换的时候会自动加上<code>&lt;ol&gt;&lt;li&gt;</code>。</p>

<h4>链接</h4>

<p>链接也是很常用的，只需要使用<code>[文字](链接地址，title)</code>形式就可以了。其中tile可以省略。值得注意的是，链接地址不需要加上&#8221;&ldquo;来包含，否则会在当前路径下寻找资源。转换的时候会自动加上<code>&lt;a href&gt;</code>。</p>

<h4>HTML</h4>

<p>Markdown兼容HTML,可以直接使用HTML标签。</p>

<p>不过对区块元素，比如<code>&lt;div&gt;、&lt;table&gt;、&lt;pre&gt;、&lt;p&gt;</code>等标签必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格来缩进。Markdown 的生成器有足够智能，不会在 HTML 区块标签外加上不必要的 <code>&lt;p&gt;</code> 标签。需要注意一点的是HTML 区块标签间的 Markdown格式语法将不会被处理。</p>

<p>而HTML的区段标签则可以随意使用，而且其中的Markdown格式语法是有效的。</p>

<p>我这里只列出了一些我觉得比较常用的一些语法，Markdown确实很方便，可以节约很多排版格式的时间，其实还有很多别的比如图片、文字强调等，有兴趣了解更多的，可以看这个<a href="http://markdown.tw/">链接</a>，如果我在写博客的过程中发现有更多常用的语法，也会继续更新。最后推荐一个在mac上写Markdown的app：mou，这个app很方便使用，可以实时预览，同时convert功能可以免去我们记忆这些Markdown语法，但是考虑效率的话，个人还是觉得记住这些语法更好，熟能生巧，用的多了自然也就都记住了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[柴静-看见]]></title>
    <link href="http://straybirdzls.github.io/blog/2014/11/01/chuaijing/"/>
    <updated>2014-11-01T20:00:50+08:00</updated>
    <id>http://straybirdzls.github.io/blog/2014/11/01/chuaijing</id>
    <content type="html"><![CDATA[<p>今天在网易公开课上看了柴静新书发布的一个<a href="http://v.163.com/movie/2014/7/V/6/MA1I1BARD_MA1II0AV6.html">视频</a>,看完之后蛮有感触的，我不懂新闻学，也不懂传播，但是我仍然能从这位知性女性温柔而又坚定中的阐述中获得力量。</p>

<!--more-->


<h3>关于独立和自由</h3>

<p>柴静在回答一个读者的提问中，提到独立这个话题。她说，</p>

<blockquote><p>我们那时候，陈虻审我们的片子，老有一些意见，甚至就直接把我们的片子毙了。我们就很不爽，就跟他抗议，说你限制我表达。他就说，限制你表达？请问你有思想吗？让你表达，你能表达什么呀？他每次问这个的时候，你就愣一下，真的，把我放在一孤岛上，给我一个本儿一支笔，你能写吗？能写出红楼梦么？够呛吧啊。因为你心灵里面空空荡荡，什么都没有，敲一下都有回声，你还想要自由么？所以就是胡适说的这个“独立更重要”。所谓的独立，就是说不要把责任推诿于外界，也不要把外界当成是一个比较和参照。二十出头的时候我也有学习，我会拿各国记者的采访来模仿，这是必须经过的过程，你就从抄袭开始模仿、学习。然后你会有一个雄心说，我也想成为一个什么样的记者，我也想改造世界。但到后面，就像卢安克说的说，你想影响别人的时候，你是影响不了的。别人知道了你的动机，他就不接受了。你想改造世界，如果他不接受，你能改造么？你会怎样？会失望吗？会放弃吗？所以人到最后就会像一个秤砣一样，回到自己的心里面，很沉很沉地把自己压住，不要把自己的责任推给外界，说我出生在一个贫寒的家庭里面，或者我在一个县城二流的中学上过学，或者我只能上一个专科学校，或者我只能在一个领导不喜欢我的环境里工作，这些都是对外界的推诿。所谓的独立就是，此时此刻此地的我，我是否有不足跟蒙昧，假如有，那我就要像那个叶子一样，拼了全身的力气我也要挣脱出来，从那个蜷缩当中，一点一点地舒展出来，完成自己的生命的一个姿态。所以人不是要跟别人去比较，人是要完成。你把老天爷给你的局限用到最大处，等你完全张开的时候，你的生命也就没有什么遗憾了。</p></blockquote>

<p>这一段话不禁让我沉思，我们也常常叫宣着要自由，可是给了我们自由，我们又可以干些什么，我们的生活跟现在又有什么差距？如果现在老天真的给我自由，没有工作，没有压力，不愁钱花，我想也许高兴几天之后我就会陷入无尽的恐慌之中，因为我的内心世界太不丰富，我不足以支撑起这样看似自由自在的生活，我无法完成自己一个人对自己的对话，过不了多久我定当陷入被自由所束缚的生活。我想我还不能理解什么是真正的自由，因为我还没有一个完全独立的人格。我时常会抱怨，时常会觉得生活不如意，工作不开心，时常自己觉得自己在一个角落之中，无法走出，其实这些全都是自己给自己设置局限。嗯，二十几岁的我甚深知我有太多的不足和矇昧，既然这样，那就努力挣脱吧。我想，这段话值得我每天都来读一遍。</p>

<h3>关于常识与智慧</h3>

<p>柴静在回答一个读者的提问中，提到了常识和智慧，</p>

<blockquote><p>对于人来说，真正属于精神世界的规律就那么两条，并不多，也不复杂，古往今来有智慧的人，他们所说的也无非就是那几句话。<br/>
我们知道了多少、理解了多少，最重要的是我们实践了多少。</p></blockquote>

<p>是的，其实想想，人生的大道理我们听了太多太多，生活中的小道理我们也听了不少，可是实际上真正实践起来的到底有几个呢？其实很多智者和伟人懂得和知道的道理并不会比我们多太多，但却是终其一身去践行，这才造就了他们杰出，他们的不一样。嗯，我没有雄心要成为伟人或者名人，但我至少想成为一个睿智的人，一个对社会有用的人，一个可以让自己过上自己想要的生活的人，我想如果能够坚持实践自己已明白的一些道理，应该能向这些目标靠近一步吧。</p>

<h3>关于提问</h3>

<p>有一个读者问到了人文关怀的问题，柴静回答道:</p>

<blockquote><p>抱歉，我没有听太懂，学术书籍看的很少，对这些术语不是很明白。但是我想起六哥，比如我在讲话的时候，大家在生活里聊天，我也问很多这种宏观的问题，六哥总是提醒我说，柴姑娘你不要问这种比较大的问题，上帝存在吗或者人生有什么意义，其实这是蛮难回答的，除了释迦摩尼之外，可能蛮难回答。他就说，你越具体越好，越平实越好。所以我自己的采访当中会比较注意一点，尽量问对方比较具体可知的问题，越简单、越愚蠢、越像孩子一样提问的时候，反而容易得到一个比较完整的答案</p></blockquote>

<p>其实不仅对待别人提问如此，对待自己也是如此，不管是自问自答，还是脑袋里的天马行空，以现在的人生阅历，或者是终其一生，我都无法回答自己人生的意义到底是什么；到底应该追求什么等等，反而这些问题会让自己陷入恐慌之中，因为想太多就会觉得人生都是虚无，一切的追求都是镜花水月。嗯，想这些，不如实在点，问问自己：这项工作有没有办法做得更好？今天有在进步吗？等等更加实在得问题，带给自己的帮助应该会更多吧。</p>

<h3>尾声－榜样</h3>

<p>看完这个视频，我突然想到榜样这个话题。记得以前高中的时候，老师让我们把自己榜样的名字写在黑板上，我特别清楚地记得当时我写的是“居里夫人”，还觉得自己这几个字写得特别好看，肯定会被老师一眼看到。人生中确实很需要榜样，那会学习特别努力，根本没有人逼我，但我就是很爱学习，学的很开心，也不觉得辛苦，我想跟那时候心目中的榜样很有关系，那时候就觉得自己的梦想就是成为一个科学家。后来也不知道是什么时候开始，大概觉得自己当不了科学家了，这个梦想被搞丢了，然后之后心目中似乎也就没有什么榜样了。再后来进入社会，觉得女性的位置很特殊，在事业上有建树的大部分婚姻不幸，婚姻生活很美满的大概都会在事业上做出一些牺牲，竟发现很难去寻找到一个榜样。不过到了今天我突然发现，把女性就这样归于2类是非常幼稚的，每个人都在追求自己的生活，我们需要的也不是过上别人的生活，仅仅是在某些时刻在某些人身上去寻找一些力量罢了。嗯，今天从柴静身上找到了一股力量，&lt;看见>也出版很久了，以前一直想看看，但最终还是没买，今天看完这个视频，决定一定要买来好好品读。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C单例模式之ARC+GCD实现]]></title>
    <link href="http://straybirdzls.github.io/blog/2014/10/28/arc/"/>
    <updated>2014-10-28T19:30:43+08:00</updated>
    <id>http://straybirdzls.github.io/blog/2014/10/28/arc</id>
    <content type="html"><![CDATA[<p>单例模式是什么，这里姑且不谈，只谈谈ARC+GCD实现下单例模式比较特殊和受争议的点。</p>

<p>首先看一个ARC+GCD实现：</p>

<pre><code>@interface Singleton : NSObject
+ (Singleton *)sharedInstance;     
@end     

@implementation Singleton     
static  Singleton *sharedInstance = nil ;             
+ (Singleton *) sharedInstance           
{      
    static dispatch_once_t onceToken;  // 锁      
    dispatch_once (&amp; onceToken, ^ {     // 最多调用一次        
    sharedInstance = [[self alloc] init];         
    });      
    return  sharedInstance;            
}        
@end       
</code></pre>

<!--more-->


<p>这个实现很简单，但是并不能防止用户通过[[Singleton alloc]init]创建多个实例，通过小小的测试即可：</p>

<pre><code>Singleton *signleton1= [Singleton sharedInstance];       
NSLog(@"singleton1 is %@",signleton1);       
Singleton *signleton2= [[Singleton alloc]init];       
NSLog(@"singleton2 is %@",signleton2);       
</code></pre>

<p>可以看出多个实例被创建出来了。</p>

<p>怎么防止这一点呢？我们需要注意的几点：<br/>
1.Objective-c并不像C++那样，可以直接将构造函数设成private，使外部不能调用<br/>
2.只能考虑在alloc分配内存的时候把路给堵死<br/>
3.alloc中实际上调用了allocWithZone:，就算把alloc堵死了，也不能防止allocWithZone被用户直接调用<br/>
&ndash;>>所以我们必须通过allocWithZone将用户堵死</p>

<p>参考<a href="" title="https://developer.apple.com/legacy/library/documentation/Cocoa/Conceptual/CocoaFundamentals/CocoaObjects/CocoaObjects.html#//apple_ref/doc/uid/TP40002974-CH4-SW32">非ARC的实现</a>，我们很容易写出如下所示的代码：</p>

<pre><code>+(instanceType)allocWithZone:(struc _NZone)zone  
{  
    return [self sharedInstance];  
}    
</code></pre>

<p>但一运行，会发现程序hang住了。分析程序可知，程序在block中block住了。同样考虑到线程安全，allocWithZone的代码应该这样写：</p>

<pre><code>+(instanceType)allocWithZone:(struc _NZone)zone  
{   
    static dispatch_once_t onceToken;  
    dispatch_once(&amp;onceToken,^{  
    sharedInstance = [super allocWithZone:zone];
    });  
    return sharedInstance;   
}   
</code></pre>

<p>再运行之前的测试代码，这回单例只有一个了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[成长悄然来临]]></title>
    <link href="http://straybirdzls.github.io/blog/2014/10/22/title/"/>
    <updated>2014-10-22T17:36:54+08:00</updated>
    <id>http://straybirdzls.github.io/blog/2014/10/22/title</id>
    <content type="html"><![CDATA[<p>今天终于成功在github上开通个人博客了，主要是想记录生活和学习。但今天只谈生活，不谈学习。</p>

<h3>序</h3>

<p>不知不觉中已经在杭州待了1年半了，回想起，似乎大部分时光都过得很简单。最近时常有种长大了，不再是小孩子了的感觉，但内心却是无比地抗拒，想永远地当个孩子，想永远无忧无虑，永远不知道伤心，难过，孤独是什么滋味。但就如同突然开始在意起自己地长相，突然开始明白人与人的差距一样，成长就是这样，它悄然来袭，给你一个措手不及。</p>

<!--more-->


<h3>成长之痛</h3>

<p>我已不记得成长这一瞬间是什么时候降临的，只记得，当看到公园里的孩子嬉戏着的时候，我知道我长大了；当给家里打电话只报喜不报忧的时候，我知道我长大了；当处在城市之中，看着身边的高达大厦，明白了为什么每个人都为了房子奋斗的时候，我知道我长大了；当内心里非常难过，但却发现无法言说，只等到一切尘埃落定，再云轻风淡地与人提之时，我知道我长大了；当被人爽约时，不再急躁处理，而是拼命地换位思考，最后一笑了之地时候，我知道我长大了；当对待别人的要求和期待越来越低地时候，我知道我长大了。</p>

<p>这种时刻回想起来实在太多，所以很多时候我也真的以为我是一个大人了，可以成熟稳重地处理很多事情，可以一个人肩负一片天，可发现一切都没那么简单。否则为什么在夜深人静地时候，会觉得无比地孤独？为什么在伤心难过绝望的时候，会不停地问自己，当初为什么选择来到这里，又为什么要坚持，为什么不回到父母身旁呢？为什么会时常觉得自己不属于这里，甚至不属于这个世界呢？为什么在前进的道路上却又总是犹豫不决，甚至怀疑当前所作的努力究竟有没有价值？</p>

<h3>成长之领悟</h3>

<p>其实这些问题，不出3天就会重复问自己，有时候甚至一天问自己几遍，有时候这一刻觉得自己知道答案，到下一刻又被自己推翻。也有很多人会说，人生就是自己的选择，一切的一切都是自主选择的结果。我也这么告诉自己，既然选择了，那么就要承担起带来的后果，如果能够接受半路落荒而逃，那也没问题。但每次想想前面的路，也许还是会有很多不开心，很多孤独，很多无助甚至绝望，但相比转弯就有的轻松之路，父母的庇佑，亲戚朋友的陪伴，没有压力的生活，我却总是会好不犹豫地选择前方，的确，相比看得见的未来，看不见的未来是更有吸引力的。也许有一天觉得累了倦了，觉得一切都没意义了，觉得人生的真谛在于平淡的幸福，那至少也不后悔自己曾经坚持过。对于现在的我而言，自己选择的路，跪着也要走完!</p>

<h3>尾声</h3>

<p>其实自己也不知道自己到底想写些啥，一开始半天憋不出来一个字，但又突然间行云流水，也许很多东西憋在心里太久了，很多话也许讲出來甚至写出来，能给自己一点力量，能让自己继续前行。如果幸运之中能有读者能看到我的博客，也希望能给你们带来力量。</p>
]]></content>
  </entry>
  
</feed>
